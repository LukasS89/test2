// @ts-nocheck
/* eslint-disable */
/* tslint:disable */
/* prettier-ignore-start */

/** @jsxRuntime classic */
/** @jsx createPlasmicElementProxy */
/** @jsxFrag React.Fragment */

// This class is auto-generated by Plasmic; please do not edit!
// Plasmic Project: 7YxWRrh3dN23tQ7PqjX2hp
// Component: y5bK6cuiDfRH

import * as React from "react";

import Head from "next/head";
import Link, { LinkProps } from "next/link";
import { useRouter } from "next/router";

import {
  Flex as Flex__,
  MultiChoiceArg,
  PlasmicDataSourceContextProvider as PlasmicDataSourceContextProvider__,
  PlasmicIcon as PlasmicIcon__,
  PlasmicImg as PlasmicImg__,
  PlasmicLink as PlasmicLink__,
  PlasmicPageGuard as PlasmicPageGuard__,
  SingleBooleanChoiceArg,
  SingleChoiceArg,
  Stack as Stack__,
  StrictProps,
  Trans as Trans__,
  classNames,
  createPlasmicElementProxy,
  deriveRenderOpts,
  ensureGlobalVariants,
  generateOnMutateForSpec,
  generateStateOnChangeProp,
  generateStateOnChangePropForCodeComponents,
  generateStateValueProp,
  get as $stateGet,
  hasVariant,
  initializeCodeComponentStates,
  initializePlasmicStates,
  makeFragment,
  omit,
  pick,
  renderPlasmicSlot,
  set as $stateSet,
  useCurrentUser,
  useDollarState,
  usePlasmicTranslator,
  useTrigger,
  wrapWithClassName
} from "@plasmicapp/react-web";
import {
  DataCtxReader as DataCtxReader__,
  useDataEnv,
  useGlobalActions
} from "@plasmicapp/react-web/lib/host";

import Header from "../../Header"; // plasmic-import: uZX7p1wyVbCa/component
import CategoryMenu from "../../CategoryMenu"; // plasmic-import: nREGSf5d9U6b/component
import { Embed } from "@plasmicpkgs/plasmic-basic-components";
import SubCategoryItem from "../../SubCategoryItem"; // plasmic-import: QQmpzqRW7UA6/component
import { Timer } from "@plasmicpkgs/plasmic-basic-components";
import { DataFetcher } from "@plasmicpkgs/plasmic-query";
import { InfiniteScrollPageEntry } from "@components/InfiniteScrollPageEntry"; // plasmic-import: J7qBqbW8kgi4/codeComponent
import ResultBoxEvents from "../../ResultBoxEvents"; // plasmic-import: YbZTs13C0bC8/component

import { useScreenVariants as useScreenVariantssdh9N1Hl4P9M } from "./PlasmicGlobalVariant__Screen"; // plasmic-import: SDH9n1Hl4p9m/globalVariant

import "@plasmicapp/react-web/lib/plasmic.css";

import plasmic_antd_5_hostless_css from "../antd_5_hostless/plasmic.module.css"; // plasmic-import: ohDidvG9XsCeFumugENU3J/projectcss
import plasmic_plasmic_rich_components_css from "../plasmic_rich_components/plasmic.module.css"; // plasmic-import: jkU633o1Cz7HrJdwdxhVHk/projectcss
import projectcss from "./plasmic.module.css"; // plasmic-import: 7YxWRrh3dN23tQ7PqjX2hp/projectcss
import sty from "./PlasmicCategory.module.css"; // plasmic-import: y5bK6cuiDfRH/css

createPlasmicElementProxy;

export type PlasmicCategory__VariantMembers = {};
export type PlasmicCategory__VariantsArgs = {};
type VariantPropType = keyof PlasmicCategory__VariantsArgs;
export const PlasmicCategory__VariantProps = new Array<VariantPropType>();

export type PlasmicCategory__ArgsType = {};
type ArgPropType = keyof PlasmicCategory__ArgsType;
export const PlasmicCategory__ArgProps = new Array<ArgPropType>();

export type PlasmicCategory__OverridesType = {
  root?: Flex__<"div">;
  section?: Flex__<"section">;
  header?: Flex__<typeof Header>;
  main?: Flex__<"main">;
  categoryMenu?: Flex__<typeof CategoryMenu>;
  filter?: Flex__<"div">;
  _return?: Flex__<"div">;
  subCategoryList?: Flex__<"div">;
  categoryFade?: Flex__<typeof Embed>;
  subCategoryItem?: Flex__<typeof SubCategoryItem>;
  resultList?: Flex__<"div">;
  text?: Flex__<"div">;
  infiniteScrollPageEntry?: Flex__<typeof InfiniteScrollPageEntry>;
  scrollTracker?: Flex__<typeof Embed>;
};

export interface DefaultCategoryProps {}

const $$ = {};

function useNextRouter() {
  try {
    return useRouter();
  } catch {}
  return undefined;
}

function PlasmicCategory__RenderFunc(props: {
  variants: PlasmicCategory__VariantsArgs;
  args: PlasmicCategory__ArgsType;
  overrides: PlasmicCategory__OverridesType;
  forNode?: string;
}) {
  const { variants, overrides, forNode } = props;

  const args = React.useMemo(
    () =>
      Object.assign(
        {},
        Object.fromEntries(
          Object.entries(props.args).filter(([_, v]) => v !== undefined)
        )
      ),
    [props.args]
  );

  const $props = {
    ...args,
    ...variants
  };

  const __nextRouter = useNextRouter();
  const $ctx = useDataEnv?.() || {};
  const refsRef = React.useRef({});
  const $refs = refsRef.current;

  const stateSpecs: Parameters<typeof useDollarState>[0] = React.useMemo(
    () => [
      {
        path: "categoryMenu.selectedItem",
        type: "private",
        variableType: "object",
        initFunc: ({ $props, $state, $queries, $ctx }) =>
          (() => {
            try {
              return JSON.parse(
                localStorage.getItem("queryCache")
              ).category.find(item => item.webURL === $ctx.params.category);
            } catch (e) {
              if (
                e instanceof TypeError ||
                e?.plasmicType === "PlasmicUndefinedDataError"
              ) {
                return {};
              }
              throw e;
            }
          })()
      },
      {
        path: "offset",
        type: "private",
        variableType: "number",
        initFunc: ({ $props, $state, $queries, $ctx }) => 0
      },
      {
        path: "categoryMenu.selectedSubcategory",
        type: "private",
        variableType: "text",
        initFunc: ({ $props, $state, $queries, $ctx }) => ({})
      },
      {
        path: "fade",
        type: "private",
        variableType: "boolean",
        initFunc: ({ $props, $state, $queries, $ctx }) => true
      },
      {
        path: "categoryMenu.selectedEvent",
        type: "private",
        variableType: "object",
        initFunc: ({ $props, $state, $queries, $ctx }) =>
          (() => {
            try {
              return JSON.parse(localStorage.getItem("queryCache")).events.find(
                item => item.webUrl === $props.eventUrl
              );
            } catch (e) {
              if (
                e instanceof TypeError ||
                e?.plasmicType === "PlasmicUndefinedDataError"
              ) {
                return {};
              }
              throw e;
            }
          })()
      }
    ],
    [$props, $ctx, $refs]
  );
  const $state = useDollarState(stateSpecs, {
    $props,
    $ctx,
    $queries: {},
    $refs
  });

  const globalVariants = ensureGlobalVariants({
    screen: useScreenVariantssdh9N1Hl4P9M()
  });

  return (
    <React.Fragment>
      <Head></Head>

      <style>{`
        body {
          margin: 0;
        }
      `}</style>

      <div
        data-plasmic-name={"root"}
        data-plasmic-override={overrides.root}
        data-plasmic-root={true}
        data-plasmic-for-node={forNode}
        className={classNames(
          projectcss.all,
          projectcss.root_reset,
          projectcss.plasmic_default_styles,
          projectcss.plasmic_mixins,
          projectcss.plasmic_tokens,
          plasmic_antd_5_hostless_css.plasmic_tokens,
          plasmic_plasmic_rich_components_css.plasmic_tokens,
          sty.root
        )}
      >
        <section
          data-plasmic-name={"section"}
          data-plasmic-override={overrides.section}
          className={classNames(projectcss.all, sty.section)}
        >
          <div className={classNames(projectcss.all, sty.freeBox___4UitT)}>
            <Header
              data-plasmic-name={"header"}
              data-plasmic-override={overrides.header}
              className={classNames("__wab_instance", sty.header)}
            />
          </div>
          <main
            data-plasmic-name={"main"}
            data-plasmic-override={overrides.main}
            className={classNames(projectcss.all, sty.main)}
          >
            {(() => {
              const child$Props = {
                className: classNames("__wab_instance", sty.categoryMenu),
                onSelectedEventChange: async (...eventArgs: any) => {
                  generateStateOnChangeProp($state, [
                    "categoryMenu",
                    "selectedEvent"
                  ]).apply(null, eventArgs);

                  if (
                    eventArgs.length > 1 &&
                    eventArgs[1] &&
                    eventArgs[1]._plasmic_state_init_
                  ) {
                    return;
                  }
                },
                onSelectedItemChange: async (...eventArgs: any) => {
                  generateStateOnChangeProp($state, [
                    "categoryMenu",
                    "selectedItem"
                  ]).apply(null, eventArgs);

                  if (
                    eventArgs.length > 1 &&
                    eventArgs[1] &&
                    eventArgs[1]._plasmic_state_init_
                  ) {
                    return;
                  }

                  (async val => {
                    const $steps = {};

                    $steps["updateOffset"] = true
                      ? (() => {
                          const actionArgs = {
                            variable: {
                              objRoot: $state,
                              variablePath: ["offset"]
                            },
                            operation: 0,
                            value: 0
                          };
                          return (({
                            variable,
                            value,
                            startIndex,
                            deleteCount
                          }) => {
                            if (!variable) {
                              return;
                            }
                            const { objRoot, variablePath } = variable;

                            $stateSet(objRoot, variablePath, value);
                            return value;
                          })?.apply(null, [actionArgs]);
                        })()
                      : undefined;
                    if (
                      $steps["updateOffset"] != null &&
                      typeof $steps["updateOffset"] === "object" &&
                      typeof $steps["updateOffset"].then === "function"
                    ) {
                      $steps["updateOffset"] = await $steps["updateOffset"];
                    }
                  }).apply(null, eventArgs);
                },
                onSelectedSubcategoryChange: async (...eventArgs: any) => {
                  generateStateOnChangeProp($state, [
                    "categoryMenu",
                    "selectedSubcategory"
                  ]).apply(null, eventArgs);

                  if (
                    eventArgs.length > 1 &&
                    eventArgs[1] &&
                    eventArgs[1]._plasmic_state_init_
                  ) {
                    return;
                  }
                },
                selectedEvent: generateStateValueProp($state, [
                  "categoryMenu",
                  "selectedEvent"
                ]),
                selectedItem: generateStateValueProp($state, [
                  "categoryMenu",
                  "selectedItem"
                ]),
                selectedSubcategory: generateStateValueProp($state, [
                  "categoryMenu",
                  "selectedSubcategory"
                ])
              };

              initializePlasmicStates(
                $state,
                [
                  {
                    name: "categoryMenu.selectedItem",
                    initFunc: ({ $props, $state, $queries }) =>
                      (() => {
                        try {
                          return JSON.parse(
                            localStorage.getItem("queryCache")
                          ).category.find(
                            item => item.webURL === $ctx.params.category
                          );
                        } catch (e) {
                          if (
                            e instanceof TypeError ||
                            e?.plasmicType === "PlasmicUndefinedDataError"
                          ) {
                            return {};
                          }
                          throw e;
                        }
                      })()
                  }
                ],
                []
              );
              return (
                <CategoryMenu
                  data-plasmic-name={"categoryMenu"}
                  data-plasmic-override={overrides.categoryMenu}
                  {...child$Props}
                />
              );
            })()}
            <div className={classNames(projectcss.all, sty.freeBox__aXKne)}>
              <div
                className={classNames(projectcss.all, sty.freeBox__gb91P)}
                id={``}
              >
                <div
                  data-plasmic-name={"filter"}
                  data-plasmic-override={overrides.filter}
                  className={classNames(projectcss.all, sty.filter)}
                />

                {(() => {
                  try {
                    return $state.categoryMenu.selectedItem !== undefined;
                  } catch (e) {
                    if (
                      e instanceof TypeError ||
                      e?.plasmicType === "PlasmicUndefinedDataError"
                    ) {
                      return true;
                    }
                    throw e;
                  }
                })() ? (
                  <div
                    data-plasmic-name={"_return"}
                    data-plasmic-override={overrides._return}
                    className={classNames(projectcss.all, sty._return)}
                    id={"fadeInStack"}
                  >
                    <div
                      data-plasmic-name={"subCategoryList"}
                      data-plasmic-override={overrides.subCategoryList}
                      className={classNames(
                        projectcss.all,
                        sty.subCategoryList
                      )}
                    >
                      {(() => {
                        try {
                          return $ctx.Data.subcategoryList !== undefined
                            ? "hidden"
                            : false;
                        } catch (e) {
                          if (
                            e instanceof TypeError ||
                            e?.plasmicType === "PlasmicUndefinedDataError"
                          ) {
                            return true;
                          }
                          throw e;
                        }
                      })() ? (
                        <Embed
                          data-plasmic-name={"categoryFade"}
                          data-plasmic-override={overrides.categoryFade}
                          className={classNames(
                            "__wab_instance",
                            sty.categoryFade
                          )}
                          code={
                            "<style>\r\n    #fadeInStack {\r\n      visibility: hidden; /* Initially hidden */\r\n      opacity: 0;\r\n      animation: fadeIn 200ms ease-in-out 100ms forwards; /* 200ms duration with 100ms delay */\r\n    }\r\n\r\n    @keyframes fadeIn {\r\n      0% {\r\n        visibility: visible; /* Set visibility to visible at the start of the animation */\r\n        opacity: 0; /* Start with 0 opacity */\r\n      }\r\n      99% {\r\n        visibility: visible; /* Keep it visible during the fade */\r\n        opacity: 1; /* Transition to full opacity */\r\n      }\r\n      100% {\r\n        visibility: visible; /* Ensure it stays visible after the transition */\r\n        opacity: 1; /* End with full opacity */\r\n      }\r\n    }\r\n</style>"
                          }
                        />
                      ) : null}
                      {(_par =>
                        !_par ? [] : Array.isArray(_par) ? _par : [_par])(
                        (() => {
                          try {
                            return $state.categoryMenu.selectedItem
                              .subcategoryList;
                          } catch (e) {
                            if (
                              e instanceof TypeError ||
                              e?.plasmicType === "PlasmicUndefinedDataError"
                            ) {
                              return [];
                            }
                            throw e;
                          }
                        })()
                      ).map((__plasmic_item_0, __plasmic_idx_0) => {
                        const subcategoryItem = __plasmic_item_0;
                        const subcategoryError = __plasmic_idx_0;
                        return (
                          <PlasmicLink__
                            className={classNames(
                              projectcss.all,
                              projectcss.a,
                              sty.link__mvoak
                            )}
                            component={Link}
                            id={"fadeAction"}
                            key={subcategoryError}
                            onClick={async event => {
                              const $steps = {};

                              $steps["updateSelectedSubcategory2"] = true
                                ? (() => {
                                    const actionArgs = {
                                      variable: {
                                        objRoot: $state,
                                        variablePath: ["fade"]
                                      },
                                      operation: 0,
                                      value: false
                                    };
                                    return (({
                                      variable,
                                      value,
                                      startIndex,
                                      deleteCount
                                    }) => {
                                      if (!variable) {
                                        return;
                                      }
                                      const { objRoot, variablePath } =
                                        variable;

                                      $stateSet(objRoot, variablePath, value);
                                      return value;
                                    })?.apply(null, [actionArgs]);
                                  })()
                                : undefined;
                              if (
                                $steps["updateSelectedSubcategory2"] != null &&
                                typeof $steps["updateSelectedSubcategory2"] ===
                                  "object" &&
                                typeof $steps["updateSelectedSubcategory2"]
                                  .then === "function"
                              ) {
                                $steps["updateSelectedSubcategory2"] =
                                  await $steps["updateSelectedSubcategory2"];
                              }

                              $steps["updateCategoryMenuSelectedSubcategory"] =
                                true
                                  ? (() => {
                                      const actionArgs = {
                                        variable: {
                                          objRoot: $state,
                                          variablePath: [
                                            "categoryMenu",
                                            "selectedSubcategory"
                                          ]
                                        },
                                        operation: 0,
                                        value: subcategoryItem
                                      };
                                      return (({
                                        variable,
                                        value,
                                        startIndex,
                                        deleteCount
                                      }) => {
                                        if (!variable) {
                                          return;
                                        }
                                        const { objRoot, variablePath } =
                                          variable;

                                        $stateSet(objRoot, variablePath, value);
                                        return value;
                                      })?.apply(null, [actionArgs]);
                                    })()
                                  : undefined;
                              if (
                                $steps[
                                  "updateCategoryMenuSelectedSubcategory"
                                ] != null &&
                                typeof $steps[
                                  "updateCategoryMenuSelectedSubcategory"
                                ] === "object" &&
                                typeof $steps[
                                  "updateCategoryMenuSelectedSubcategory"
                                ].then === "function"
                              ) {
                                $steps[
                                  "updateCategoryMenuSelectedSubcategory"
                                ] = await $steps[
                                  "updateCategoryMenuSelectedSubcategory"
                                ];
                              }
                            }}
                            platform={"nextjs"}
                          >
                            <SubCategoryItem
                              data-plasmic-name={"subCategoryItem"}
                              data-plasmic-override={overrides.subCategoryItem}
                              className={classNames(
                                "__wab_instance",
                                sty.subCategoryItem
                              )}
                              color={(() => {
                                try {
                                  return $state.categoryMenu.selectedItem.color;
                                } catch (e) {
                                  if (
                                    e instanceof TypeError ||
                                    e?.plasmicType ===
                                      "PlasmicUndefinedDataError"
                                  ) {
                                    return ``;
                                  }
                                  throw e;
                                }
                              })()}
                              selected={(() => {
                                try {
                                  return (
                                    subcategoryItem.name ===
                                    $state.categoryMenu.selectedSubcategory.name
                                  );
                                } catch (e) {
                                  if (
                                    e instanceof TypeError ||
                                    e?.plasmicType ===
                                      "PlasmicUndefinedDataError"
                                  ) {
                                    return false;
                                  }
                                  throw e;
                                }
                              })()}
                              subCategoryItemData={(() => {
                                try {
                                  return subcategoryItem;
                                } catch (e) {
                                  if (
                                    e instanceof TypeError ||
                                    e?.plasmicType ===
                                      "PlasmicUndefinedDataError"
                                  ) {
                                    return undefined;
                                  }
                                  throw e;
                                }
                              })()}
                            />

                            <Timer
                              className={classNames(
                                "__wab_instance",
                                sty.timer__iYrbw
                              )}
                              intervalSeconds={0.15}
                              isRunning={(() => {
                                try {
                                  return !$state.fade;
                                } catch (e) {
                                  if (
                                    e instanceof TypeError ||
                                    e?.plasmicType ===
                                      "PlasmicUndefinedDataError"
                                  ) {
                                    return true;
                                  }
                                  throw e;
                                }
                              })()}
                              onTick={async () => {
                                const $steps = {};

                                $steps["updateFade"] = true
                                  ? (() => {
                                      const actionArgs = {
                                        variable: {
                                          objRoot: $state,
                                          variablePath: ["fade"]
                                        },
                                        operation: 0,
                                        value: true
                                      };
                                      return (({
                                        variable,
                                        value,
                                        startIndex,
                                        deleteCount
                                      }) => {
                                        if (!variable) {
                                          return;
                                        }
                                        const { objRoot, variablePath } =
                                          variable;

                                        $stateSet(objRoot, variablePath, value);
                                        return value;
                                      })?.apply(null, [actionArgs]);
                                    })()
                                  : undefined;
                                if (
                                  $steps["updateFade"] != null &&
                                  typeof $steps["updateFade"] === "object" &&
                                  typeof $steps["updateFade"].then ===
                                    "function"
                                ) {
                                  $steps["updateFade"] = await $steps[
                                    "updateFade"
                                  ];
                                }
                              }}
                              runWhileEditing={false}
                            />
                          </PlasmicLink__>
                        );
                      })}
                    </div>
                    <div
                      data-plasmic-name={"resultList"}
                      data-plasmic-override={overrides.resultList}
                      className={classNames(projectcss.all, sty.resultList)}
                      style={(() => {
                        try {
                          return {
                            visibility: $state.fade ? "visible" : "hidden",
                            opacity: $state.fade ? 1 : 0,
                            animation: $state.fade
                              ? "fadeIn 200ms ease-in-out"
                              : "none",
                            transition: "opacity 200ms ease-in-out" // Optional: smooth transition for opacity changes
                          };
                        } catch (e) {
                          if (
                            e instanceof TypeError ||
                            e?.plasmicType === "PlasmicUndefinedDataError"
                          ) {
                            return undefined;
                          }
                          throw e;
                        }
                      })()}
                    >
                      <div
                        data-plasmic-name={"text"}
                        data-plasmic-override={overrides.text}
                        className={classNames(projectcss.all, sty.text)}
                      >
                        <div
                          className={classNames(
                            projectcss.all,
                            projectcss.__wab_text,
                            sty.text__ixu9F
                          )}
                        >
                          {"Pr\u00e1v\u011b si prohl\u00ed\u017e\u00edte "}
                        </div>
                        <div
                          className={classNames(
                            projectcss.all,
                            projectcss.__wab_text,
                            sty.text__n7BKn
                          )}
                          style={(() => {
                            try {
                              return {
                                color: $state.categoryMenu.selectedItem.color
                              };
                            } catch (e) {
                              if (
                                e instanceof TypeError ||
                                e?.plasmicType === "PlasmicUndefinedDataError"
                              ) {
                                return undefined;
                              }
                              throw e;
                            }
                          })()}
                        >
                          <React.Fragment>
                            {(() => {
                              try {
                                return $state.categoryMenu.selectedItem.name;
                              } catch (e) {
                                if (
                                  e instanceof TypeError ||
                                  e?.plasmicType === "PlasmicUndefinedDataError"
                                ) {
                                  return "";
                                }
                                throw e;
                              }
                            })()}
                          </React.Fragment>
                        </div>
                        {(() => {
                          try {
                            return (
                              $state.categoryMenu.selectedSubcategory &&
                              Object.keys(
                                $state.categoryMenu.selectedSubcategory
                              ).length > 0
                            );
                          } catch (e) {
                            if (
                              e instanceof TypeError ||
                              e?.plasmicType === "PlasmicUndefinedDataError"
                            ) {
                              return true;
                            }
                            throw e;
                          }
                        })() ? (
                          <div
                            className={classNames(
                              projectcss.all,
                              projectcss.__wab_text,
                              sty.text__zhDEp
                            )}
                            style={(() => {
                              try {
                                return {
                                  color: $state.categoryMenu.selectedItem.color
                                };
                              } catch (e) {
                                if (
                                  e instanceof TypeError ||
                                  e?.plasmicType === "PlasmicUndefinedDataError"
                                ) {
                                  return undefined;
                                }
                                throw e;
                              }
                            })()}
                          >
                            <React.Fragment>
                              {(() => {
                                try {
                                  return (
                                    " - " +
                                    $state.categoryMenu.selectedSubcategory.name
                                  );
                                } catch (e) {
                                  if (
                                    e instanceof TypeError ||
                                    e?.plasmicType ===
                                      "PlasmicUndefinedDataError"
                                  ) {
                                    return "";
                                  }
                                  throw e;
                                }
                              })()}
                            </React.Fragment>
                          </div>
                        ) : null}
                      </div>
                      <div
                        className={classNames(
                          projectcss.all,
                          sty.freeBox__jkq7
                        )}
                      >
                        {(_par =>
                          !_par ? [] : Array.isArray(_par) ? _par : [_par])(
                          (() => {
                            try {
                              return (() => {
                                const itemCount = $state.offset + 1;
                                const repeatableCollection = Array.from(
                                  { length: itemCount },
                                  (_, index) => index + 1
                                );
                                return repeatableCollection;
                              })();
                            } catch (e) {
                              if (
                                e instanceof TypeError ||
                                e?.plasmicType === "PlasmicUndefinedDataError"
                              ) {
                                return [];
                              }
                              throw e;
                            }
                          })()
                        ).map((__plasmic_item_0, __plasmic_idx_0) => {
                          const apiItem = __plasmic_item_0;
                          const apiIndex = __plasmic_idx_0;
                          return (
                            <PlasmicLink__
                              className={classNames(
                                projectcss.all,
                                projectcss.a,
                                sty.link__zAcpe
                              )}
                              component={Link}
                              key={apiIndex}
                              platform={"nextjs"}
                            >
                              <DataFetcher
                                className={classNames(
                                  "__wab_instance",
                                  sty.httpRestApiFetcher__m2Cln
                                )}
                                dataName={(() => {
                                  try {
                                    return `data-${apiIndex}`;
                                  } catch (e) {
                                    if (
                                      e instanceof TypeError ||
                                      e?.plasmicType ===
                                        "PlasmicUndefinedDataError"
                                    ) {
                                      return undefined;
                                    }
                                    throw e;
                                  }
                                })()}
                                errorDisplay={null}
                                errorName={"fetchError"}
                                headers={{
                                  "Content-Type": "application/json",
                                  apikey:
                                    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJucmZkeHRzZHZteGhqc29xb2lkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjE4MjQyNTcsImV4cCI6MjAzNzQwMDI1N30.N-1_fY2KLrl9sxmeM8z3bRc-b0ksQ0C4IWQpugCs65I"
                                }}
                                loadingDisplay={
                                  <DataCtxReader__>
                                    {$ctx => (
                                      <div
                                        className={classNames(
                                          projectcss.all,
                                          sty.freeBox__zoaR9
                                        )}
                                      >
                                        {(_par =>
                                          !_par
                                            ? []
                                            : Array.isArray(_par)
                                            ? _par
                                            : [_par])(
                                          (() => {
                                            try {
                                              return [
                                                1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
                                                11, 12, 13, 14, 15, 16, 17, 18,
                                                19, 20
                                              ];
                                            } catch (e) {
                                              if (
                                                e instanceof TypeError ||
                                                e?.plasmicType ===
                                                  "PlasmicUndefinedDataError"
                                              ) {
                                                return [];
                                              }
                                              throw e;
                                            }
                                          })()
                                        ).map(
                                          (
                                            __plasmic_item_1,
                                            __plasmic_idx_1
                                          ) => {
                                            const currentItem =
                                              __plasmic_item_1;
                                            const currentIndex =
                                              __plasmic_idx_1;
                                            return (
                                              <PlasmicLink__
                                                className={classNames(
                                                  projectcss.all,
                                                  projectcss.a,
                                                  sty.link__jx39Y
                                                )}
                                                component={Link}
                                                key={currentIndex}
                                                platform={"nextjs"}
                                              />
                                            );
                                          }
                                        )}
                                      </div>
                                    )}
                                  </DataCtxReader__>
                                }
                                method={"GET"}
                                noLayout={true}
                                url={(() => {
                                  try {
                                    return (() => {
                                      let rangeStart = apiIndex * 20;
                                      let rangeEnd = rangeStart + 19;
                                      let categoryName =
                                        $state.categoryMenu.selectedItem.name;
                                      let selectedSubCategory =
                                        $state.categoryMenu.selectedSubcategory
                                          .name;
                                      const url =
                                        "https://rnrfdxtsdvmxhjsoqoid.supabase.co/rest/v1/events?category=eq." +
                                        categoryName +
                                        (selectedSubCategory &&
                                        selectedSubCategory !== ""
                                          ? '&subCategory=ov.{"' +
                                            selectedSubCategory +
                                            '"}'
                                          : "") +
                                        "&offset=" +
                                        rangeStart +
                                        "&limit=" +
                                        (rangeEnd - rangeStart + 1);
                                      return url;
                                    })();
                                  } catch (e) {
                                    if (
                                      e instanceof TypeError ||
                                      e?.plasmicType ===
                                        "PlasmicUndefinedDataError"
                                    ) {
                                      return undefined;
                                    }
                                    throw e;
                                  }
                                })()}
                              >
                                <DataCtxReader__>
                                  {$ctx => (
                                    <React.Fragment>
                                      <Timer
                                        className={classNames(
                                          "__wab_instance",
                                          sty.timer__ozCun
                                        )}
                                        intervalSeconds={0.1}
                                        isRunning={(() => {
                                          try {
                                            return $ctx["data-0"] !== undefined;
                                          } catch (e) {
                                            if (
                                              e instanceof TypeError ||
                                              e?.plasmicType ===
                                                "PlasmicUndefinedDataError"
                                            ) {
                                              return false;
                                            }
                                            throw e;
                                          }
                                        })()}
                                        onTick={async () => {
                                          const $steps = {};

                                          $steps["updateFade"] = true
                                            ? (() => {
                                                const actionArgs = {
                                                  variable: {
                                                    objRoot: $state,
                                                    variablePath: ["fade"]
                                                  },
                                                  operation: 0,
                                                  value: true
                                                };
                                                return (({
                                                  variable,
                                                  value,
                                                  startIndex,
                                                  deleteCount
                                                }) => {
                                                  if (!variable) {
                                                    return;
                                                  }
                                                  const {
                                                    objRoot,
                                                    variablePath
                                                  } = variable;

                                                  $stateSet(
                                                    objRoot,
                                                    variablePath,
                                                    value
                                                  );
                                                  return value;
                                                })?.apply(null, [actionArgs]);
                                              })()
                                            : undefined;
                                          if (
                                            $steps["updateFade"] != null &&
                                            typeof $steps["updateFade"] ===
                                              "object" &&
                                            typeof $steps["updateFade"].then ===
                                              "function"
                                          ) {
                                            $steps["updateFade"] = await $steps[
                                              "updateFade"
                                            ];
                                          }
                                        }}
                                        runWhileEditing={false}
                                      />

                                      <InfiniteScrollPageEntry
                                        data-plasmic-name={
                                          "infiniteScrollPageEntry"
                                        }
                                        data-plasmic-override={
                                          overrides.infiniteScrollPageEntry
                                        }
                                        className={classNames(
                                          "__wab_instance",
                                          sty.infiniteScrollPageEntry
                                        )}
                                        onPageEnter={async () => {
                                          const $steps = {};

                                          $steps["updateOffset"] =
                                            $ctx[`data-${apiIndex}`] !== null &&
                                            $ctx[`data-${apiIndex}`] !==
                                              undefined &&
                                            $ctx[`data-${apiIndex}`].length > 0
                                              ? (() => {
                                                  const actionArgs = {
                                                    variable: {
                                                      objRoot: $state,
                                                      variablePath: ["offset"]
                                                    },
                                                    operation: 2
                                                  };
                                                  return (({
                                                    variable,
                                                    value,
                                                    startIndex,
                                                    deleteCount
                                                  }) => {
                                                    if (!variable) {
                                                      return;
                                                    }
                                                    const {
                                                      objRoot,
                                                      variablePath
                                                    } = variable;

                                                    const oldValue = $stateGet(
                                                      objRoot,
                                                      variablePath
                                                    );
                                                    $stateSet(
                                                      objRoot,
                                                      variablePath,
                                                      oldValue + 1
                                                    );
                                                    return oldValue + 1;
                                                  })?.apply(null, [actionArgs]);
                                                })()
                                              : undefined;
                                          if (
                                            $steps["updateOffset"] != null &&
                                            typeof $steps["updateOffset"] ===
                                              "object" &&
                                            typeof $steps["updateOffset"]
                                              .then === "function"
                                          ) {
                                            $steps["updateOffset"] =
                                              await $steps["updateOffset"];
                                          }
                                        }}
                                      >
                                        <div
                                          className={classNames(
                                            projectcss.all,
                                            sty.freeBox__syEta
                                          )}
                                        >
                                          {(_par =>
                                            !_par
                                              ? []
                                              : Array.isArray(_par)
                                              ? _par
                                              : [_par])(
                                            (() => {
                                              try {
                                                return (() => {
                                                  const dataKey = `data-${apiIndex}`;
                                                  const dataValue =
                                                    $ctx[dataKey];
                                                  return dataValue;
                                                })();
                                              } catch (e) {
                                                if (
                                                  e instanceof TypeError ||
                                                  e?.plasmicType ===
                                                    "PlasmicUndefinedDataError"
                                                ) {
                                                  return [];
                                                }
                                                throw e;
                                              }
                                            })()
                                          ).map(
                                            (
                                              __plasmic_item_1,
                                              __plasmic_idx_1
                                            ) => {
                                              const currentItem =
                                                __plasmic_item_1;
                                              const currentIndex =
                                                __plasmic_idx_1;
                                              return (
                                                <PlasmicLink__
                                                  className={classNames(
                                                    projectcss.all,
                                                    projectcss.a,
                                                    sty.link__vkH2G
                                                  )}
                                                  component={Link}
                                                  key={currentIndex}
                                                  platform={"nextjs"}
                                                >
                                                  <PlasmicLink__
                                                    className={classNames(
                                                      projectcss.all,
                                                      projectcss.a,
                                                      sty.link__yMwpm
                                                    )}
                                                    component={Link}
                                                    onClick={async event => {
                                                      const $steps = {};

                                                      $steps["runCode"] = true
                                                        ? (() => {
                                                            const actionArgs = {
                                                              customFunction:
                                                                async () => {
                                                                  return (async () => {
                                                                    try {
                                                                      const cachedData =
                                                                        JSON.parse(
                                                                          localStorage.getItem(
                                                                            "queryCache"
                                                                          ) ||
                                                                            "{}"
                                                                        );
                                                                      cachedData.events =
                                                                        [
                                                                          currentItem
                                                                        ];
                                                                      localStorage.setItem(
                                                                        "queryCache",
                                                                        JSON.stringify(
                                                                          cachedData
                                                                        )
                                                                      );
                                                                    } catch (error) {}
                                                                  })();
                                                                }
                                                            };
                                                            return (({
                                                              customFunction
                                                            }) => {
                                                              return customFunction();
                                                            })?.apply(null, [
                                                              actionArgs
                                                            ]);
                                                          })()
                                                        : undefined;
                                                      if (
                                                        $steps["runCode"] !=
                                                          null &&
                                                        typeof $steps[
                                                          "runCode"
                                                        ] === "object" &&
                                                        typeof $steps["runCode"]
                                                          .then === "function"
                                                      ) {
                                                        $steps["runCode"] =
                                                          await $steps[
                                                            "runCode"
                                                          ];
                                                      }

                                                      $steps[
                                                        "updateCategoryMenuSelectedEvent"
                                                      ] = true
                                                        ? (() => {
                                                            const actionArgs = {
                                                              variable: {
                                                                objRoot: $state,
                                                                variablePath: [
                                                                  "categoryMenu",
                                                                  "selectedEvent"
                                                                ]
                                                              },
                                                              operation: 0,
                                                              value: currentItem
                                                            };
                                                            return (({
                                                              variable,
                                                              value,
                                                              startIndex,
                                                              deleteCount
                                                            }) => {
                                                              if (!variable) {
                                                                return;
                                                              }
                                                              const {
                                                                objRoot,
                                                                variablePath
                                                              } = variable;

                                                              $stateSet(
                                                                objRoot,
                                                                variablePath,
                                                                value
                                                              );
                                                              return value;
                                                            })?.apply(null, [
                                                              actionArgs
                                                            ]);
                                                          })()
                                                        : undefined;
                                                      if (
                                                        $steps[
                                                          "updateCategoryMenuSelectedEvent"
                                                        ] != null &&
                                                        typeof $steps[
                                                          "updateCategoryMenuSelectedEvent"
                                                        ] === "object" &&
                                                        typeof $steps[
                                                          "updateCategoryMenuSelectedEvent"
                                                        ].then === "function"
                                                      ) {
                                                        $steps[
                                                          "updateCategoryMenuSelectedEvent"
                                                        ] = await $steps[
                                                          "updateCategoryMenuSelectedEvent"
                                                        ];
                                                      }

                                                      $steps["goToEvent"] = true
                                                        ? (() => {
                                                            const actionArgs = {
                                                              destination: `/${(() => {
                                                                try {
                                                                  return $ctx
                                                                    .params
                                                                    .category;
                                                                } catch (e) {
                                                                  if (
                                                                    e instanceof
                                                                      TypeError ||
                                                                    e?.plasmicType ===
                                                                      "PlasmicUndefinedDataError"
                                                                  ) {
                                                                    return undefined;
                                                                  }
                                                                  throw e;
                                                                }
                                                              })()}/${(() => {
                                                                try {
                                                                  return currentItem.webUrl;
                                                                } catch (e) {
                                                                  if (
                                                                    e instanceof
                                                                      TypeError ||
                                                                    e?.plasmicType ===
                                                                      "PlasmicUndefinedDataError"
                                                                  ) {
                                                                    return undefined;
                                                                  }
                                                                  throw e;
                                                                }
                                                              })()}`
                                                            };
                                                            return (({
                                                              destination
                                                            }) => {
                                                              if (
                                                                typeof destination ===
                                                                  "string" &&
                                                                destination.startsWith(
                                                                  "#"
                                                                )
                                                              ) {
                                                                document
                                                                  .getElementById(
                                                                    destination.substr(
                                                                      1
                                                                    )
                                                                  )
                                                                  .scrollIntoView(
                                                                    {
                                                                      behavior:
                                                                        "smooth"
                                                                    }
                                                                  );
                                                              } else {
                                                                __nextRouter?.push(
                                                                  destination
                                                                );
                                                              }
                                                            })?.apply(null, [
                                                              actionArgs
                                                            ]);
                                                          })()
                                                        : undefined;
                                                      if (
                                                        $steps["goToEvent"] !=
                                                          null &&
                                                        typeof $steps[
                                                          "goToEvent"
                                                        ] === "object" &&
                                                        typeof $steps[
                                                          "goToEvent"
                                                        ].then === "function"
                                                      ) {
                                                        $steps["goToEvent"] =
                                                          await $steps[
                                                            "goToEvent"
                                                          ];
                                                      }
                                                    }}
                                                    platform={"nextjs"}
                                                  >
                                                    <ResultBoxEvents
                                                      className={classNames(
                                                        "__wab_instance",
                                                        sty.resultBoxEvents__vFgqU
                                                      )}
                                                      color={
                                                        $state.categoryMenu
                                                          .selectedItem.color
                                                      }
                                                      data={(() => {
                                                        try {
                                                          return currentItem;
                                                        } catch (e) {
                                                          if (
                                                            e instanceof
                                                              TypeError ||
                                                            e?.plasmicType ===
                                                              "PlasmicUndefinedDataError"
                                                          ) {
                                                            return undefined;
                                                          }
                                                          throw e;
                                                        }
                                                      })()}
                                                    />
                                                  </PlasmicLink__>
                                                </PlasmicLink__>
                                              );
                                            }
                                          )}
                                        </div>
                                      </InfiniteScrollPageEntry>
                                    </React.Fragment>
                                  )}
                                </DataCtxReader__>
                              </DataFetcher>
                            </PlasmicLink__>
                          );
                        })}
                        {false
                          ? (_par =>
                              !_par ? [] : Array.isArray(_par) ? _par : [_par])(
                              (() => {
                                try {
                                  return (() => {
                                    const itemCount = $state.offset + 1;
                                    const repeatableCollection = Array.from(
                                      { length: itemCount },
                                      (_, index) => index + 1
                                    );
                                    return repeatableCollection;
                                  })();
                                } catch (e) {
                                  if (
                                    e instanceof TypeError ||
                                    e?.plasmicType ===
                                      "PlasmicUndefinedDataError"
                                  ) {
                                    return [];
                                  }
                                  throw e;
                                }
                              })()
                            ).map((__plasmic_item_0, __plasmic_idx_0) => {
                              const apiItem = __plasmic_item_0;
                              const apiIndex = __plasmic_idx_0;
                              return (
                                <PlasmicLink__
                                  className={classNames(
                                    projectcss.all,
                                    projectcss.a,
                                    sty.link__yaOvj
                                  )}
                                  component={Link}
                                  key={apiIndex}
                                  platform={"nextjs"}
                                >
                                  <DataFetcher
                                    className={classNames(
                                      "__wab_instance",
                                      sty.httpRestApiFetcher__t2Vd
                                    )}
                                    dataName={(() => {
                                      try {
                                        return `data-${apiIndex}`;
                                      } catch (e) {
                                        if (
                                          e instanceof TypeError ||
                                          e?.plasmicType ===
                                            "PlasmicUndefinedDataError"
                                        ) {
                                          return undefined;
                                        }
                                        throw e;
                                      }
                                    })()}
                                    errorDisplay={null}
                                    errorName={"fetchError"}
                                    headers={{
                                      "Content-Type": "application/json",
                                      apikey:
                                        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJucmZkeHRzZHZteGhqc29xb2lkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjE4MjQyNTcsImV4cCI6MjAzNzQwMDI1N30.N-1_fY2KLrl9sxmeM8z3bRc-b0ksQ0C4IWQpugCs65I"
                                    }}
                                    loadingDisplay={
                                      <DataCtxReader__>
                                        {$ctx => (
                                          <div
                                            className={classNames(
                                              projectcss.all,
                                              sty.freeBox__pviB
                                            )}
                                          >
                                            {(_par =>
                                              !_par
                                                ? []
                                                : Array.isArray(_par)
                                                ? _par
                                                : [_par])(
                                              (() => {
                                                try {
                                                  return [
                                                    1, 2, 3, 4, 5, 6, 7, 8, 9,
                                                    10, 11, 12, 13, 14, 15, 16,
                                                    17, 18, 19, 20
                                                  ];
                                                } catch (e) {
                                                  if (
                                                    e instanceof TypeError ||
                                                    e?.plasmicType ===
                                                      "PlasmicUndefinedDataError"
                                                  ) {
                                                    return [];
                                                  }
                                                  throw e;
                                                }
                                              })()
                                            ).map(
                                              (
                                                __plasmic_item_1,
                                                __plasmic_idx_1
                                              ) => {
                                                const currentItem =
                                                  __plasmic_item_1;
                                                const currentIndex =
                                                  __plasmic_idx_1;
                                                return (
                                                  <PlasmicLink__
                                                    className={classNames(
                                                      projectcss.all,
                                                      projectcss.a,
                                                      sty.link___3XRwS
                                                    )}
                                                    component={Link}
                                                    key={currentIndex}
                                                    platform={"nextjs"}
                                                  />
                                                );
                                              }
                                            )}
                                          </div>
                                        )}
                                      </DataCtxReader__>
                                    }
                                    method={"GET"}
                                    noLayout={true}
                                    url={(() => {
                                      try {
                                        return (() => {
                                          let rangeStart = apiIndex * 20;
                                          let rangeEnd = rangeStart + 19;
                                          let categoryName =
                                            $state.categoryMenu.selectedItem
                                              .name;
                                          let selectedSubCategory =
                                            $state.categoryMenu
                                              .selectedSubcategory.name;
                                          const url =
                                            "https://rnrfdxtsdvmxhjsoqoid.supabase.co/rest/v1/events?category=eq." +
                                            categoryName +
                                            (selectedSubCategory &&
                                            selectedSubCategory !== ""
                                              ? '&subCategory=ov.{"' +
                                                selectedSubCategory +
                                                '"}'
                                              : "") +
                                            "&offset=" +
                                            rangeStart +
                                            "&limit=" +
                                            (rangeEnd - rangeStart + 1);
                                          return url;
                                        })();
                                      } catch (e) {
                                        if (
                                          e instanceof TypeError ||
                                          e?.plasmicType ===
                                            "PlasmicUndefinedDataError"
                                        ) {
                                          return undefined;
                                        }
                                        throw e;
                                      }
                                    })()}
                                  >
                                    <DataCtxReader__>
                                      {$ctx => (
                                        <React.Fragment>
                                          <Timer
                                            className={classNames(
                                              "__wab_instance",
                                              sty.timer__fstc0
                                            )}
                                            intervalSeconds={0.1}
                                            isRunning={(() => {
                                              try {
                                                return (
                                                  $ctx["data-0"] !== undefined
                                                );
                                              } catch (e) {
                                                if (
                                                  e instanceof TypeError ||
                                                  e?.plasmicType ===
                                                    "PlasmicUndefinedDataError"
                                                ) {
                                                  return false;
                                                }
                                                throw e;
                                              }
                                            })()}
                                            onTick={async () => {
                                              const $steps = {};

                                              $steps["updateFade"] = true
                                                ? (() => {
                                                    const actionArgs = {
                                                      variable: {
                                                        objRoot: $state,
                                                        variablePath: ["fade"]
                                                      },
                                                      operation: 0,
                                                      value: true
                                                    };
                                                    return (({
                                                      variable,
                                                      value,
                                                      startIndex,
                                                      deleteCount
                                                    }) => {
                                                      if (!variable) {
                                                        return;
                                                      }
                                                      const {
                                                        objRoot,
                                                        variablePath
                                                      } = variable;

                                                      $stateSet(
                                                        objRoot,
                                                        variablePath,
                                                        value
                                                      );
                                                      return value;
                                                    })?.apply(null, [
                                                      actionArgs
                                                    ]);
                                                  })()
                                                : undefined;
                                              if (
                                                $steps["updateFade"] != null &&
                                                typeof $steps["updateFade"] ===
                                                  "object" &&
                                                typeof $steps["updateFade"]
                                                  .then === "function"
                                              ) {
                                                $steps["updateFade"] =
                                                  await $steps["updateFade"];
                                              }
                                            }}
                                            runWhileEditing={false}
                                          />

                                          <div
                                            className={classNames(
                                              projectcss.all,
                                              sty.freeBox__ic0Ax
                                            )}
                                          >
                                            {(_par =>
                                              !_par
                                                ? []
                                                : Array.isArray(_par)
                                                ? _par
                                                : [_par])(
                                              (() => {
                                                try {
                                                  return (() => {
                                                    const dataKey = `data-${apiIndex}`;
                                                    const dataValue =
                                                      $ctx[dataKey];
                                                    return dataValue;
                                                  })();
                                                } catch (e) {
                                                  if (
                                                    e instanceof TypeError ||
                                                    e?.plasmicType ===
                                                      "PlasmicUndefinedDataError"
                                                  ) {
                                                    return [];
                                                  }
                                                  throw e;
                                                }
                                              })()
                                            ).map(
                                              (
                                                __plasmic_item_1,
                                                __plasmic_idx_1
                                              ) => {
                                                const currentItem =
                                                  __plasmic_item_1;
                                                const currentIndex =
                                                  __plasmic_idx_1;
                                                return (
                                                  <PlasmicLink__
                                                    className={classNames(
                                                      projectcss.all,
                                                      projectcss.a,
                                                      sty.link__p5GbN
                                                    )}
                                                    component={Link}
                                                    key={currentIndex}
                                                    platform={"nextjs"}
                                                  >
                                                    <PlasmicLink__
                                                      className={classNames(
                                                        projectcss.all,
                                                        projectcss.a,
                                                        sty.link__sQx62
                                                      )}
                                                      component={Link}
                                                      onClick={async event => {
                                                        const $steps = {};

                                                        $steps["runCode"] = true
                                                          ? (() => {
                                                              const actionArgs =
                                                                {
                                                                  customFunction:
                                                                    async () => {
                                                                      return (async () => {
                                                                        try {
                                                                          const cachedData =
                                                                            JSON.parse(
                                                                              localStorage.getItem(
                                                                                "queryCache"
                                                                              ) ||
                                                                                "{}"
                                                                            );
                                                                          cachedData.events =
                                                                            [
                                                                              currentItem
                                                                            ];
                                                                          localStorage.setItem(
                                                                            "queryCache",
                                                                            JSON.stringify(
                                                                              cachedData
                                                                            )
                                                                          );
                                                                        } catch (error) {}
                                                                      })();
                                                                    }
                                                                };
                                                              return (({
                                                                customFunction
                                                              }) => {
                                                                return customFunction();
                                                              })?.apply(null, [
                                                                actionArgs
                                                              ]);
                                                            })()
                                                          : undefined;
                                                        if (
                                                          $steps["runCode"] !=
                                                            null &&
                                                          typeof $steps[
                                                            "runCode"
                                                          ] === "object" &&
                                                          typeof $steps[
                                                            "runCode"
                                                          ].then === "function"
                                                        ) {
                                                          $steps["runCode"] =
                                                            await $steps[
                                                              "runCode"
                                                            ];
                                                        }

                                                        $steps[
                                                          "updateCategoryMenuSelectedEvent"
                                                        ] = true
                                                          ? (() => {
                                                              const actionArgs =
                                                                {
                                                                  variable: {
                                                                    objRoot:
                                                                      $state,
                                                                    variablePath:
                                                                      [
                                                                        "categoryMenu",
                                                                        "selectedEvent"
                                                                      ]
                                                                  },
                                                                  operation: 0,
                                                                  value:
                                                                    currentItem
                                                                };
                                                              return (({
                                                                variable,
                                                                value,
                                                                startIndex,
                                                                deleteCount
                                                              }) => {
                                                                if (!variable) {
                                                                  return;
                                                                }
                                                                const {
                                                                  objRoot,
                                                                  variablePath
                                                                } = variable;

                                                                $stateSet(
                                                                  objRoot,
                                                                  variablePath,
                                                                  value
                                                                );
                                                                return value;
                                                              })?.apply(null, [
                                                                actionArgs
                                                              ]);
                                                            })()
                                                          : undefined;
                                                        if (
                                                          $steps[
                                                            "updateCategoryMenuSelectedEvent"
                                                          ] != null &&
                                                          typeof $steps[
                                                            "updateCategoryMenuSelectedEvent"
                                                          ] === "object" &&
                                                          typeof $steps[
                                                            "updateCategoryMenuSelectedEvent"
                                                          ].then === "function"
                                                        ) {
                                                          $steps[
                                                            "updateCategoryMenuSelectedEvent"
                                                          ] = await $steps[
                                                            "updateCategoryMenuSelectedEvent"
                                                          ];
                                                        }

                                                        $steps["goToEvent"] =
                                                          true
                                                            ? (() => {
                                                                const actionArgs =
                                                                  {
                                                                    destination: `/${(() => {
                                                                      try {
                                                                        return $ctx
                                                                          .params
                                                                          .category;
                                                                      } catch (e) {
                                                                        if (
                                                                          e instanceof
                                                                            TypeError ||
                                                                          e?.plasmicType ===
                                                                            "PlasmicUndefinedDataError"
                                                                        ) {
                                                                          return undefined;
                                                                        }
                                                                        throw e;
                                                                      }
                                                                    })()}/${(() => {
                                                                      try {
                                                                        return currentItem.webUrl;
                                                                      } catch (e) {
                                                                        if (
                                                                          e instanceof
                                                                            TypeError ||
                                                                          e?.plasmicType ===
                                                                            "PlasmicUndefinedDataError"
                                                                        ) {
                                                                          return undefined;
                                                                        }
                                                                        throw e;
                                                                      }
                                                                    })()}`
                                                                  };
                                                                return (({
                                                                  destination
                                                                }) => {
                                                                  if (
                                                                    typeof destination ===
                                                                      "string" &&
                                                                    destination.startsWith(
                                                                      "#"
                                                                    )
                                                                  ) {
                                                                    document
                                                                      .getElementById(
                                                                        destination.substr(
                                                                          1
                                                                        )
                                                                      )
                                                                      .scrollIntoView(
                                                                        {
                                                                          behavior:
                                                                            "smooth"
                                                                        }
                                                                      );
                                                                  } else {
                                                                    __nextRouter?.push(
                                                                      destination
                                                                    );
                                                                  }
                                                                })?.apply(
                                                                  null,
                                                                  [actionArgs]
                                                                );
                                                              })()
                                                            : undefined;
                                                        if (
                                                          $steps["goToEvent"] !=
                                                            null &&
                                                          typeof $steps[
                                                            "goToEvent"
                                                          ] === "object" &&
                                                          typeof $steps[
                                                            "goToEvent"
                                                          ].then === "function"
                                                        ) {
                                                          $steps["goToEvent"] =
                                                            await $steps[
                                                              "goToEvent"
                                                            ];
                                                        }
                                                      }}
                                                      platform={"nextjs"}
                                                    >
                                                      <ResultBoxEvents
                                                        className={classNames(
                                                          "__wab_instance",
                                                          sty.resultBoxEvents__drPjw
                                                        )}
                                                        color={
                                                          $state.categoryMenu
                                                            .selectedItem.color
                                                        }
                                                        data={(() => {
                                                          try {
                                                            return currentItem;
                                                          } catch (e) {
                                                            if (
                                                              e instanceof
                                                                TypeError ||
                                                              e?.plasmicType ===
                                                                "PlasmicUndefinedDataError"
                                                            ) {
                                                              return undefined;
                                                            }
                                                            throw e;
                                                          }
                                                        })()}
                                                      />
                                                    </PlasmicLink__>
                                                  </PlasmicLink__>
                                                );
                                              }
                                            )}
                                          </div>
                                        </React.Fragment>
                                      )}
                                    </DataCtxReader__>
                                  </DataFetcher>
                                </PlasmicLink__>
                              );
                            })
                          : null}
                        {false ? (
                          <Embed
                            data-plasmic-name={"scrollTracker"}
                            data-plasmic-override={overrides.scrollTracker}
                            className={classNames(
                              "__wab_instance",
                              sty.scrollTracker
                            )}
                            code={(() => {
                              return (() => {
                                const trackScrollPosition = () => {
                                  const multiplier =
                                    $state.offset === 0 ? 2.5 : 2.5 * 1.5;
                                  const threshold =
                                    0.3 * window.innerHeight * multiplier;
                                  const scrollPosition = window.scrollY;
                                  const newLoadMoreValue = Math.floor(
                                    scrollPosition / threshold
                                  );
                                  if (newLoadMoreValue > $state.offset) {
                                    $state.offset = newLoadMoreValue;
                                  }
                                };
                                window.addEventListener(
                                  "scroll",
                                  trackScrollPosition
                                );
                                return `Scroll position tracking initialized.`;
                              })();
                            })()}
                          />
                        ) : null}
                      </div>
                    </div>
                  </div>
                ) : null}
              </div>
            </div>
          </main>
        </section>
      </div>
    </React.Fragment>
  ) as React.ReactElement | null;
}

const PlasmicDescendants = {
  root: [
    "root",
    "section",
    "header",
    "main",
    "categoryMenu",
    "filter",
    "_return",
    "subCategoryList",
    "categoryFade",
    "subCategoryItem",
    "resultList",
    "text",
    "infiniteScrollPageEntry",
    "scrollTracker"
  ],
  section: [
    "section",
    "header",
    "main",
    "categoryMenu",
    "filter",
    "_return",
    "subCategoryList",
    "categoryFade",
    "subCategoryItem",
    "resultList",
    "text",
    "infiniteScrollPageEntry",
    "scrollTracker"
  ],
  header: ["header"],
  main: [
    "main",
    "categoryMenu",
    "filter",
    "_return",
    "subCategoryList",
    "categoryFade",
    "subCategoryItem",
    "resultList",
    "text",
    "infiniteScrollPageEntry",
    "scrollTracker"
  ],
  categoryMenu: ["categoryMenu"],
  filter: ["filter"],
  _return: [
    "_return",
    "subCategoryList",
    "categoryFade",
    "subCategoryItem",
    "resultList",
    "text",
    "infiniteScrollPageEntry",
    "scrollTracker"
  ],
  subCategoryList: ["subCategoryList", "categoryFade", "subCategoryItem"],
  categoryFade: ["categoryFade"],
  subCategoryItem: ["subCategoryItem"],
  resultList: [
    "resultList",
    "text",
    "infiniteScrollPageEntry",
    "scrollTracker"
  ],
  text: ["text"],
  infiniteScrollPageEntry: ["infiniteScrollPageEntry"],
  scrollTracker: ["scrollTracker"]
} as const;
type NodeNameType = keyof typeof PlasmicDescendants;
type DescendantsType<T extends NodeNameType> =
  (typeof PlasmicDescendants)[T][number];
type NodeDefaultElementType = {
  root: "div";
  section: "section";
  header: typeof Header;
  main: "main";
  categoryMenu: typeof CategoryMenu;
  filter: "div";
  _return: "div";
  subCategoryList: "div";
  categoryFade: typeof Embed;
  subCategoryItem: typeof SubCategoryItem;
  resultList: "div";
  text: "div";
  infiniteScrollPageEntry: typeof InfiniteScrollPageEntry;
  scrollTracker: typeof Embed;
};

type ReservedPropsType = "variants" | "args" | "overrides";
type NodeOverridesType<T extends NodeNameType> = Pick<
  PlasmicCategory__OverridesType,
  DescendantsType<T>
>;
type NodeComponentProps<T extends NodeNameType> =
  // Explicitly specify variants, args, and overrides as objects
  {
    variants?: PlasmicCategory__VariantsArgs;
    args?: PlasmicCategory__ArgsType;
    overrides?: NodeOverridesType<T>;
  } & Omit<PlasmicCategory__VariantsArgs, ReservedPropsType> & // Specify variants directly as props
    /* Specify args directly as props*/ Omit<
      PlasmicCategory__ArgsType,
      ReservedPropsType
    > &
    /* Specify overrides for each element directly as props*/ Omit<
      NodeOverridesType<T>,
      ReservedPropsType | VariantPropType | ArgPropType
    > &
    /* Specify props for the root element*/ Omit<
      Partial<React.ComponentProps<NodeDefaultElementType[T]>>,
      ReservedPropsType | VariantPropType | ArgPropType | DescendantsType<T>
    >;

function makeNodeComponent<NodeName extends NodeNameType>(nodeName: NodeName) {
  type PropsType = NodeComponentProps<NodeName> & { key?: React.Key };
  const func = function <T extends PropsType>(
    props: T & StrictProps<T, PropsType>
  ) {
    const { variants, args, overrides } = React.useMemo(
      () =>
        deriveRenderOpts(props, {
          name: nodeName,
          descendantNames: PlasmicDescendants[nodeName],
          internalArgPropNames: PlasmicCategory__ArgProps,
          internalVariantPropNames: PlasmicCategory__VariantProps
        }),
      [props, nodeName]
    );
    return PlasmicCategory__RenderFunc({
      variants,
      args,
      overrides,
      forNode: nodeName
    });
  };
  if (nodeName === "root") {
    func.displayName = "PlasmicCategory";
  } else {
    func.displayName = `PlasmicCategory.${nodeName}`;
  }
  return func;
}

export const PlasmicCategory = Object.assign(
  // Top-level PlasmicCategory renders the root element
  makeNodeComponent("root"),
  {
    // Helper components rendering sub-elements
    section: makeNodeComponent("section"),
    header: makeNodeComponent("header"),
    main: makeNodeComponent("main"),
    categoryMenu: makeNodeComponent("categoryMenu"),
    filter: makeNodeComponent("filter"),
    _return: makeNodeComponent("_return"),
    subCategoryList: makeNodeComponent("subCategoryList"),
    categoryFade: makeNodeComponent("categoryFade"),
    subCategoryItem: makeNodeComponent("subCategoryItem"),
    resultList: makeNodeComponent("resultList"),
    text: makeNodeComponent("text"),
    infiniteScrollPageEntry: makeNodeComponent("infiniteScrollPageEntry"),
    scrollTracker: makeNodeComponent("scrollTracker"),

    // Metadata about props expected for PlasmicCategory
    internalVariantProps: PlasmicCategory__VariantProps,
    internalArgProps: PlasmicCategory__ArgProps,

    // Page metadata
    pageMetadata: {
      title: "",
      description: "",
      ogImageSrc: "",
      canonical: ""
    }
  }
);

export default PlasmicCategory;
/* prettier-ignore-end */
